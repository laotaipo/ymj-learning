多个元素组成的列表
元素存储不连续，用next指针连在一起
数组 vs 链表
    数组增删非首尾元素时需要移动元素
    链表增删首尾元素时，不需要移动元素，只需更改next的指向即可
在js中没有链表这个数据结构，但可以用Object来模拟链表


集合Set
集合是一种无序且唯一的数据结构

字典Map
一种存储唯一值的数据结构，但它是以键值对的形式来存储
字典的常用操作：键值对的增删改查

树
一种分层数据的抽象模型
前端工作中常见的树 DOM树 级联选择 树形控件
树的常用操作：深度/广度优先遍历、先中后序遍历
深度优先遍历：尽可能深的搜索树的分支
    访问根结点
    对根结点的children挨个进行深度优先遍历
广度优先遍历：先访问离根结点最近的节点
    新建一个队列，把根结点入队
    把队头出队并访问
    把队头的children挨个入队
    重复第二、三步，直到队列为空
二叉树
    树中每个节点最多只能有两个子节点
    在js中通常用Object来模拟二叉树
    先序遍历 根左右
    中序遍历 左根右
    后序遍历 左右根

图
JS中没有图，但可以用Object和 Array构建图
图的表示法：邻接矩阵、邻接表、关联矩阵
图的常用操作：
深度优先遍历
    访问根结点
    对根结点的没访问过的相邻节点挨个进行深度优先遍历
广度优先遍历
    新建一个队列，把根节点入队
    把队头出队并访问
    把队头的没访问过的相邻节点入队
堆
堆是一种特殊的完全二叉树
所有的节点都大于等于（最大堆）或小于等于（最小堆）它的子节点
js中通常用数组表示堆
任意节点的左侧子节点的位置是2*index + 1
任意节点的右侧子节点的位置是2*index + 2
任意节点的父节点位置是(index - 1) / 2
堆的应用
    堆能高效快速的找出最大值和最小值，时间复杂度O(1)
    找出第K个最大（小）元素
最小堆类实现步骤
    在类里，声明一个数组，用来装元素
    主要方法：插入、删除堆顶、获取堆顶、获取堆大小
    插入：将值插入堆的底部，即数组的尾部
    然后上移：将这个值和它的父节点进行交换，直到父节点小于等于这个插入的值
    大小为k的堆中插入元素的时间复杂度为O(logk)
    删除堆顶：用数组尾部元素替换堆顶（直接删除堆顶会破坏堆结构）
    然后下移：将新堆顶和它子节点进行交换，直到子节点大于等于这个新堆顶
    大小为k的堆中删除堆顶的时间复杂度为O(logk)
    获取堆顶：返回数组的头部
    获取堆的大小：返回数组的长度

排序和搜索
js中的排序：数组的sort方法
js中的搜索：数组的indexOf方法
排序：冒泡、选择、插入、归并、快速
搜索：顺序搜索、二分搜索
冒泡O（n2)
选择排序：每次循环找到最小的，放在第一位 O(n2)
插入排序：O(n2)
从第二个数开始往前比，比它大就往后排，以此类推进行到最后一个数
*****归并排序：O(nlogn)火狐浏览器的sort方法用的就是归并排序
分：把数组劈成两半，再递归的堆子数组进行“分”操作，直到分成一个个单独的数 O(logn)
和：把两个数组合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整数组 O(n)
合并两个有序数组：新建一个空数组res,用于存放最终排序后的数组；比较两个有序数组的头部，较小者出队并推入res中；如果两个数组还有值就重复第二步
***快速排序：O(n * logN)
分区：从数组中任意选择一个“基准”，所有比基准小的元素放在基准前面，比基准大的元素放在基准后面
递归：递归的对基准前后的子数组进行分区

*****二分搜索：从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束，如果目标值大于或小于中间元素，则在大于或小于中间元素的那一半数组中搜索 O(logN)

*****分而治之
分治是算法设计中的一种方法
它将一个问题分成多个和原问题相似的小问题递归解决小问题，再将结果合并以解决原来的问题
归并排序、快速排序都是按照分治方法

题目
题号	题目名称	时间复杂度	空间复杂度	知识点
349	两个数组的交集 	O(m+n)	O(m)	Map
20	有效的括号 	O(n)	O(n)	Map 栈
1	两数之和	O(n)	O(n)	Map
3  需复习	无重复字符的最长子串	O(n)	O(m)	双指针 滑动窗口 map
76  需复习	最小覆盖子串	O(m+n)	O(m)	双指针 滑动窗口 map

